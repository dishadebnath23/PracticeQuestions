# Practice Questions â€“ Day 2  
## Collections Framework

---

### Q1. You need to store a list of customer IDs where:
- Order of insertion must be preserved  
- Duplicate IDs are allowed  

#### Which Java collection would you use and why?

I would use an **ArrayList**.

**Why?**  
ArrayList maintains the order of insertion, meaning elements stay in the same order as they are added.  
It allows duplicate values, so the same customer ID can appear multiple times.  
It is simple, fast for read operations, and commonly used when indexing and iteration are required.

This makes ArrayList the best choice when data is ordered and duplicates are valid.

---

#### What would change if duplicates were not allowed?

If duplicates were not allowed, I would use a **LinkedHashSet**.

**Reason:**  
LinkedHashSet does not allow duplicate values and still preserves the order of insertion.  
This makes it suitable when uniqueness and order are both required.

---

### Q2. In a multi-threaded application, multiple threads update a shared collection.

#### Why are normal collections like ArrayList or HashMap not thread-safe?

Normal collections are not thread-safe because they do not handle concurrent access internally.  
If multiple threads modify the collection at the same time, it can lead to data inconsistency, race conditions, or runtime exceptions like `ConcurrentModificationException`.

---

#### Name one thread-safe collection in Java.

One commonly used thread-safe collection is **ConcurrentHashMap**.

---

#### When would you prefer a Concurrent collection over Collections.synchronizedList()?

Concurrent collections are preferred in high-concurrency scenarios because they provide better performance.  
They use fine-grained locking or lock-free mechanisms, whereas synchronized collections lock the entire structure, reducing scalability.

---

### Q3. If an ArrayList is initialized with a size of 25 and a 26th element is added, what happens internally?

When the 26th element is added, the ArrayList automatically resizes its internal array.  
A new larger array is created, existing elements are copied into it, and then the new element is added.  
This resizing operation is expensive, which is why setting an appropriate initial capacity is recommended.

---

### Q4. Remove duplicates from a list of employee names while preserving insertion order (case-insensitive).

**Input:**  
`["John", "Alice", "john", "Bob", "Alice", "BOB"]`

**Output:**  
John
Alice
Bob


#### Approach

I use a **LinkedHashMap** where:
- The key is the lowercase version of the name (for case-insensitive comparison)
- The value is the original name (to preserve formatting)

---

#### Code

java
import java.util.*;

public class EmployeeNames {
    public static void main(String[] args) {

        List<String> names = Arrays.asList(
                "John", "Alice", "john", "Bob", "Alice", "BOB"
        );

        Map<String, String> uniqueNames = new LinkedHashMap<>();

        for (String name : names) {
            uniqueNames.putIfAbsent(name.toLowerCase(), name);
        }

        for (String name : uniqueNames.values()) {
            System.out.println(name);
        }
    }
}
